/*
 * Script for compressing food images. Extracts image urls from data export and compresses
 * images through TinyPNG api.
 *
 * Usage: node compress.js
 */
const fs = require("fs");
const path = require("path");

const tinify = require("tinify");

const compressed = require("./src/data/compressed.js");
const { getImageId } = require("./src/utils.js");
const { FOOD_IMAGES_PATH } = require("./src/constants.js");

// Load up environment variables
require("dotenv").config();

// Constants
// ----------------------------------------------------------------------------
const IMAGES_PATH = path.resolve(__dirname, "src", FOOD_IMAGES_PATH);
const COMPRESSED_PATH = path.resolve(__dirname, "src", "data", "compressed.js");
const SUCCESS_KEY = "succeeded";
const FAILED_KEY = "failed";

// Helpers
// ----------------------------------------------------------------------------
const getImageUrls = (data) => {
  const urls = data.entries.map((x) => x.imageURL).filter((x) => x);
  return [...new Set(urls)];
};

const onCompressError = (err, url) => {
  let detail;
  if (err instanceof tinify.AccountError) {
    detail = `The error message is: ${err.message}. Verify your API key and account limit.`;
  } else if (err instanceof tinify.ClientError) {
    detail = "Check your source image and request options.";
  } else if (err instanceof tinify.ServerError) {
    detail = "Temporary issue with the Tinify API.";
  } else if (err instanceof tinify.ConnectionError) {
    detail = "A network connection error occurred.";
  } else {
    detail = "Something else went wrong, unrelated to the Tinify API";
  }
  console.log(`Error compressing ${url}! Details: ${detail}`);
};

const compressImage = ({ url, id }) => {
  console.log(`\nCompressing ${url}\n`);

  const outputPath = path.join(IMAGES_PATH, id);
  return tinify
    .fromUrl(url)
    .toFile(outputPath)
    .then((_) => {
      console.log(`Successful compressed ${url}, saved to ${outputPath}`);
      return { url, status: SUCCESS_KEY };
    })
    .catch((err) => {
      onCompressError(err, url);
      return { url, status: FAILED_KEY };
    });
};

const generateCompressedModule = (processed) => {
  const imageCount = fs.readdirSync(IMAGES_PATH).length;
  const imageStr = fs
    .readdirSync(IMAGES_PATH)
    .map((name) => `'${name}'`)
    .join(", ");
  const content = `// AUTOGENERATED FILE (from compress.js)
// DO NOT MANUALLY UPDATE THIS FILE UNLESS YOU KNOW WHAT YOU'RE DOING
// ---------------------------------------------------------------------------

module.exports = [${imageStr}];
`;
  fs.writeFileSync(COMPRESSED_PATH, content);
  return [processed, imageCount];
};

const logOutput = (ids, skipCount, processed, imageCount) => {
  const output = `
-------------------- Output --------------------
Urls read: ${ids.length}
Urls skipped: ${skipCount}
Urls processed: ${processed[SUCCESS_KEY].length + processed[FAILED_KEY].length}
Urls succeded: ${processed[SUCCESS_KEY].length}
Urls failed: ${processed[FAILED_KEY].length}
Urls failed list: ${processed[FAILED_KEY].map((x) => x)}
------------------------------------------------

Total compressed images: ${imageCount}
Compression count for this month: ${tinify.compressionCount}
`;
  console.log(output);
};

// Main
// ----------------------------------------------------------------------------

// Auth w/ TinyPNG
const apiKey = process.env.TINY_PNG_API_KEY;
if (!apiKey) {
  console.log(`Error! TINY_PNG_API_KEY is ${apiKey} -- set it in .env`);
  process.exit(1);
}
tinify.key = apiKey;

const compressedSet = new Set(compressed);
const dataPath = path.resolve(__dirname, "src", "data", "food.json");
const rawData = JSON.parse(fs.readFileSync(dataPath, "utf8"));
const ids = getImageUrls(rawData).map((url) => ({ url, id: getImageId(url) }));
const skipCount = ids.filter((x) => compressedSet.has(x.id)).length;
if (ids.length === skipCount) {
  const imageCount = fs.readdirSync(IMAGES_PATH).length;
  console.log("No new images found, nothing to compress!");
  console.log(`Total compressed images: ${imageCount}`);
  process.exit(0);
}

const idsToProcess = ids
  .filter((x) => !compressedSet.has(x.id))
  .map((x) => compressImage(x));
Promise.all(idsToProcess)
  // Create results map
  .then((results) =>
    results.reduce(
      (xs, x) => {
        const key = x.status;
        xs[key].push(x.url);
        return xs;
      },
      { [SUCCESS_KEY]: [], [FAILED_KEY]: [] }
    )
  )
  .then((processed) => generateCompressedModule(processed))
  .then(([processed, imageCount]) =>
    logOutput(ids, skipCount, processed, imageCount)
  )
  .then(() => process.exit(0));
